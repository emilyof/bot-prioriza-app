import functools
import logging
import time
from typing import TYPE_CHECKING, Optional

import requests

from app.core.vulnerability_types import VulnerabilityType
from app.messages.bot_messages import BotMessages
from app.services.owasp_service import OWASPService
from app.utils.helpers import retry_with_backoff
from app.utils.input_validator import InputValidator

if TYPE_CHECKING:
    from app.services.ai_service import AIService

logger = logging.getLogger(__name__)


class VulnerabilityService:
    """
    Serviço de domínio responsável por calcular score técnico base.

    Regras:
    - NÃO faz parsing de IA
    - NÃO aplica guard-rails de score IA
    - Apenas orquestra fontes técnicas (CVE, OWASP, IA)
    """

    def __init__(
        self,
        vulncheck_api_token: Optional[str] = None,
        messages: Optional[BotMessages] = None,
        ai_service: Optional["AIService"] = None,
        owasp_service: Optional[OWASPService] = None,
    ):
        self.EPSS_URL = "https://api.first.org/data/v1/epss"
        self.NIST_BASE_URL = "https://services.nvd.nist.gov/rest/json/cves/2.0"
        self.CISA_KEV_URL = (
            "https://www.cisa.gov/sites/default/files/feeds/" "known_exploited_vulnerabilities.json"
        )
        self.VULNCHECK_BASE_URL = "https://api.vulncheck.com/v3/index/vulncheck-kev/"

        self.VULNCHECK_API_TOKEN = vulncheck_api_token
        self.messages = messages if messages else BotMessages()
        self.ai_service = ai_service
        self.owasp_service = owasp_service or OWASPService()

        self.default_technical_scores = {
            VulnerabilityType.OWASP: {
                "technical_subtotal": 35.0,
                "description_ai": "N/A",
            },
            VulnerabilityType.CVE: {
                "technical_subtotal": 0.0,
                "description_ai": "N/A",
                "av_n": False,
            },
            "CVE_NOT_FOUND": {
                "technical_subtotal": 0.0,
                "description_ai": "N/A",
            },
            VulnerabilityType.AI_SCORING_DESCRIPTION: {
                "technical_subtotal": 0.0,
                "description_ai": "N/A",
            },
        }

        self._cisa_kev_cache = None
        self._cisa_kev_cache_expiry = 0
        self.CISA_KEV_CACHE_TTL = 3600

        logger.info("[VULN-SERVICE] VulnerabilityService inicializado com observabilidade")

    # ==========================================================
    # API principal
    # ==========================================================

    def calculate_technical_score(
        self,
        identifier: str,
        input_type: VulnerabilityType,
        user_id: Optional[str] = None,
    ) -> Optional[dict]:
        """
        Retorna SEMPRE um dicionário técnico no contrato padrão
        ou None em caso de falha.

        ✅ REGRAS IMPORTANTES:
        - IA NÃO define score OWASP
        - OWASP é resolvido pelo domínio (OWASPService)
        - Categoria fora da lista atual → score mínimo (30)
        """

        # SCORING POR DESCRIÇÃO (IA)
        if input_type == VulnerabilityType.AI_SCORING_DESCRIPTION:
            is_valid, error, sanitized_description = InputValidator.validate_description(identifier)

            if not is_valid:
                logger.error(f"[VALIDATION] Descrição inválida para user {user_id}: {error}")
                return None

            if not self.ai_service:
                logger.error("[AI_SCORING] AIService não configurado.")
                return None

            ai_result = self.ai_service.calculate_technical_score_by_description(
                description=sanitized_description
            )

            if not ai_result:
                logger.warning("[AI_SCORING] IA não retornou resultado válido")
                return None

            data = self.default_technical_scores[VulnerabilityType.AI_SCORING_DESCRIPTION].copy()

            data["technical_subtotal"] = ai_result["technical_subtotal"]
            data["description_ai"] = sanitized_description
            data["ai_justification"] = ai_result.get("justification")

            return data

        # SCORING POR CVE (SEM ALTERAÇÃO)
        if input_type == VulnerabilityType.CVE:
            is_valid, error, sanitized_cve = InputValidator.validate_identifier(identifier)

            if not is_valid or not InputValidator.validate_cve_format(sanitized_cve):
                logger.error(f"[VALIDATION] CVE inválido para user {user_id}: {identifier}")
                return None

            return self._calculate_cve_score(sanitized_cve.upper())

        # SCORING POR OWASP
        if input_type == VulnerabilityType.OWASP:
            # ========= VALIDAÇÃO BÁSICA =========
            is_valid, error, sanitized_owasp = InputValidator.validate_identifier(identifier)

            if not is_valid:
                logger.error(f"[VALIDATION] OWASP inválido para user {user_id}: {error}")
                return None

            owasp_code = sanitized_owasp.upper()

            # ========= VALIDAÇÃO DE FORMATO =========
            # Aceita apenas A01–A10 e AI01–AI10 (sem ano)
            if not InputValidator.validate_owasp_format(owasp_code):
                logger.error(
                    f"[VALIDATION] Formato OWASP inválido: {owasp_code}. " f"User: {user_id}"
                )
                return None

            logger.info(
                f"[VALIDATION] OWASP validado com sucesso: {owasp_code}. " f"User: {user_id}"
            )

            data = self.default_technical_scores[VulnerabilityType.OWASP].copy()

            # ========= RESOLUÇÃO VIA OWASP SERVICE =========
            category = self.owasp_service.resolve_by_code(owasp_code)

            # ========= CATEGORIA EXISTE NO TOP 10 =========
            if category:
                rank = category.rank

                # Distribuição linear:
                # Rank 1 → 60 | Rank 10 → 30
                score = 60 - ((rank - 1) * (30 / 9))

                data["technical_subtotal"] = round(score, 1)
                data["description_ai"] = category.title
                data["score_explanation"] = (
                    "Pontuação técnica baseada na posição da categoria " "no OWASP TOP 10."
                )

                logger.info(
                    f"[OWASP] Categoria resolvida: {category.code} | "
                    f"{category.title} | Rank {rank}"
                )

            # ========= CATEGORIA FORA DO TOP 10 =========
            else:
                data["technical_subtotal"] = 30.0
                data["description_ai"] = (
                    "Categoria OWASP informada não faz parte " "da versão mais recente do TOP 10."
                )
                data["score_explanation"] = (
                    "Categoria OWASP fora do TOP 10 atual. " "Pontuação técnica mínima aplicada."
                )

                logger.warning(f"[OWASP] Categoria fora da lista atual: {owasp_code}")

            return data

        # Tipo desconhecido
        logger.error(
            f"[VALIDATION] Tipo de vulnerabilidade desconhecido: {input_type}. " f"User: {user_id}"
        )
        return None

    # ==========================================================
    # CVE — lógica técnica
    # ==========================================================

    def _calculate_cve_score(self, cve_id: str) -> dict:
        """
        Calcula score técnico para CVE (0–60).

        Integrações:
        - NVD (CVSS 4.0 / 3.x)
        - EPSS
        - CISA KEV
        - VulnCheck (POC)
        """

        logger.info(f"[CVE_SCORE] Iniciando cálculo técnico para {cve_id}")

        # ==================================================
        # Validação defensiva
        # ==================================================
        if not InputValidator.validate_cve_format(cve_id):
            logger.error(
                f"[CVE_SCORE] Formato CVE inválido: "
                f"{InputValidator.sanitize_for_logging(cve_id)}"
            )
            return self.default_technical_scores["CVE_NOT_FOUND"].copy()

        technical_data = self.default_technical_scores[VulnerabilityType.CVE].copy()

        # ==================================================
        # 1️⃣ NVD / CVSS
        # ==================================================
        nvd_data = self.get_nist_nvd_data(cve_id)

        if not nvd_data:
            logger.info(
                f"[CVE_SCORE] CVE encontrado no NIST, mas sem CVSS publicado ainda: {cve_id}"  # noqa: E501
            )
            technical_data["cvss_score"] = 0.0
            technical_data["cvss_status"] = "AWAITING_ANALYSIS"
            return technical_data

        technical_data.update(nvd_data)
        technical_data["technical_subtotal"] += nvd_data.get("cvss_score", 0)

        logger.info(
            f"[CVE_SCORE][NVD] CVSS {nvd_data.get('cvss_version')} aplicado | "
            f"Score={nvd_data.get('cvss_score')} | "
            f"Vector={nvd_data.get('attack_vector_string')}"
        )

        # ==================================================
        # 2️⃣ EPSS
        # ==================================================
        epss_score, epss_qualitative = self.get_epss_score(cve_id)
        technical_data["technical_subtotal"] += epss_score
        technical_data["epss_qualitative"] = epss_qualitative

        logger.info(
            f"[CVE_SCORE][EPSS] Score aplicado: {epss_score:.1f} | "
            f"Probabilidade: {epss_qualitative}"
        )

        # ==================================================
        # 3️⃣ CISA KEV
        # ==================================================
        kev_score, kev_qualitative = self.get_cisa_kev(cve_id)
        technical_data["technical_subtotal"] += kev_score
        technical_data["kev_qualitative"] = kev_qualitative

        logger.info(
            f"[CVE_SCORE][KEV] Explorado ativamente: {kev_qualitative} | " f"Score: {kev_score}"
        )

        # ==================================================
        # 4️⃣ VulnCheck (POC)
        # ==================================================
        vulncheck_score, vulncheck_data = self.get_vulncheck_data(cve_id)
        technical_data["technical_subtotal"] += vulncheck_score
        technical_data.update(vulncheck_data)

        if vulncheck_score > 0:
            logger.info("[CVE_SCORE][VULNCHECK] POC identificado")
        else:
            logger.info("[CVE_SCORE][VULNCHECK] Nenhum POC identificado")

        # ==================================================
        # 5️⃣ Cap técnico (máx. 60)
        # ==================================================
        technical_data["technical_subtotal"] = min(technical_data["technical_subtotal"], 60)

        logger.info(
            f"[CVE_SCORE] Score técnico FINAL para {cve_id}: "
            f"{technical_data['technical_subtotal']:.1f}/60"
        )

        return technical_data

    # ==========================================================
    # Integrações externas
    # ==========================================================

    @retry_with_backoff()
    def _fetch_data(self, url, headers=None, params=None):
        response = requests.get(url, headers=headers, params=params, timeout=15)
        response.raise_for_status()
        return response.json()

    def get_epss_score(self, cve_id):
        data = self._fetch_data(self.EPSS_URL, params={"cve": cve_id})
        if data.get("data"):
            epss = float(data["data"][0].get("epss", 0))
            return min(epss * 10, 10), f"{epss:.2%}"
        return 0.0, "Não disponível"

    def get_nist_nvd_data(self, cve_id: str) -> Optional[dict]:
        data = self._fetch_data(
            self.NIST_BASE_URL,
            params={"cveId": cve_id},
        )

        if not data or not data.get("vulnerabilities"):
            return None

        cve = data["vulnerabilities"][0]["cve"]
        metrics = cve.get("metrics", {})

        # ==================================================
        # 1️⃣ CVSS 4.0 (formato oficial NVD API 2.0)
        # ==================================================
        if "cvssMetricV40" in metrics:
            entry = metrics["cvssMetricV40"][0]
            cvss = entry.get("cvssData", {})
            vector = cvss.get("vectorString", "")

            logger.info(
                f"[CVE_SCORE][CVSS4] CVSS 4.0 encontrado | "
                f"Score={cvss.get('baseScore')} | "
                f"Source={entry.get('source')} | "
                f"Type={entry.get('type')}"
            )

            return {
                "cvss_version": "4.0",
                "cvss_source": entry.get("source"),
                "cvss_type": entry.get("type"),
                "cvss_score": min(cvss.get("baseScore", 0), 40),
                "attack_vector_string": vector,
                "av_n": "AV:N" in vector,
                "nvd_status": cve.get("vulnStatus"),
            }

        # ==================================================
        # 2️⃣ CVSS 3.1 / 3.0 (fallback)
        # ==================================================
        for key in ("cvssMetricV31", "cvssMetricV30"):
            if key in metrics:
                entry = metrics[key][0]
                cvss = entry.get("cvssData", {})
                vector = cvss.get("vectorString", "")

                logger.info(
                    f"[CVE_SCORE][CVSS3] {key} encontrado | " f"Score={cvss.get('baseScore')}"
                )

                return {
                    "cvss_version": "3.x",
                    "cvss_source": entry.get("source"),
                    "cvss_type": entry.get("type"),
                    "cvss_score": min(cvss.get("baseScore", 0), 40),
                    "attack_vector_string": vector,
                    "av_n": "AV:N" in vector,
                    "nvd_status": cve.get("vulnStatus"),
                }

        return None

    def get_vulncheck_data(self, cve_id):
        if not self.VULNCHECK_API_TOKEN:
            return 0, {}

        headers = {"Authorization": f"Bearer {self.VULNCHECK_API_TOKEN}"}
        url = f"{self.VULNCHECK_BASE_URL}{cve_id}"

        try:
            data = self._fetch_data(url, headers=headers)
        except requests.exceptions.HTTPError as e:
            if e.response is not None and e.response.status_code == 401:
                logger.info("VulnCheck retornou 401. Ignorando integração.")
                return 0, {}
            raise

        if data.get("data"):
            return 10, {"poc_qualitative": "Sim"}

        return 0, {}

    def get_cisa_kev(self, cve_id):
        now = time.time()

        if not self._cisa_kev_cache or now > self._cisa_kev_cache_expiry:
            data = self._fetch_data(self.CISA_KEV_URL)
            self._cisa_kev_cache = {item["cveID"]: item for item in data.get("vulnerabilities", [])}
            self._cisa_kev_cache_expiry = now + self.CISA_KEV_CACHE_TTL

        return (10, "Sim") if cve_id in self._cisa_kev_cache else (0, "Não")

    # ==========================================================
    # Descrição CVE
    # ==========================================================

    @functools.lru_cache(maxsize=128)
    def get_cve_description(self, cve_id: str) -> str:
        """
        Obtém descrição de um CVE da API NIST NVD.

        ✅ VALIDAÇÃO APLICADA:
        - Formato CVE válido
        - Sanitização para logs
        """

        # ========== VALIDAR FORMATO CVE ==========
        if not InputValidator.validate_cve_format(cve_id):
            logger.warning(
                f"[CVE_DESCRIPTION] Formato CVE inválido: "
                f"{InputValidator.sanitize_for_logging(cve_id)}"
            )
            return "Formato de CVE inválido."

        cve_id_upper = cve_id.upper()

        try:
            data = self._fetch_data(
                self.NIST_BASE_URL,
                params={"cveId": cve_id_upper},
            )

            if data.get("vulnerabilities"):
                for desc in data["vulnerabilities"][0]["cve"].get("descriptions", []):
                    if desc.get("lang") == "en":
                        return desc.get("value", "Descrição não disponível.")

            logger.info(f"[CVE_DESCRIPTION] Nenhuma descrição encontrada para {cve_id_upper}")
            return "Descrição não disponível."

        except Exception as e:
            logger.error(f"[CVE_DESCRIPTION] Erro ao buscar descrição para {cve_id_upper}: {e}")
            return "Erro ao buscar descrição."
